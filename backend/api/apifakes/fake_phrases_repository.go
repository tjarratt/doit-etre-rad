// This file was generated by counterfeiter
package apifakes

import (
	"sync"

	"github.com/google/uuid"
	"github.com/tjarratt/doit-etre-rad/backend/api"
)

type FakePhrasesRepository struct {
	PhrasesForUserWithUUIDStub        func(uuid.UUID) ([]api.Phrase, error)
	phrasesForUserWithUUIDMutex       sync.RWMutex
	phrasesForUserWithUUIDArgsForCall []struct {
		arg1 uuid.UUID
	}
	phrasesForUserWithUUIDReturns struct {
		result1 []api.Phrase
		result2 error
	}
	phrasesForUserWithUUIDReturnsOnCall map[int]struct {
		result1 []api.Phrase
		result2 error
	}
	AddPhraseForUserWithUUIDStub        func(string, string, uuid.UUID) (api.Phrase, error)
	addPhraseForUserWithUUIDMutex       sync.RWMutex
	addPhraseForUserWithUUIDArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 uuid.UUID
	}
	addPhraseForUserWithUUIDReturns struct {
		result1 api.Phrase
		result2 error
	}
	addPhraseForUserWithUUIDReturnsOnCall map[int]struct {
		result1 api.Phrase
		result2 error
	}
	UpdatePhraseForUserWithUUIDStub        func(string, string, uuid.UUID, uuid.UUID) (api.Phrase, error)
	updatePhraseForUserWithUUIDMutex       sync.RWMutex
	updatePhraseForUserWithUUIDArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 uuid.UUID
		arg4 uuid.UUID
	}
	updatePhraseForUserWithUUIDReturns struct {
		result1 api.Phrase
		result2 error
	}
	updatePhraseForUserWithUUIDReturnsOnCall map[int]struct {
		result1 api.Phrase
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePhrasesRepository) PhrasesForUserWithUUID(arg1 uuid.UUID) ([]api.Phrase, error) {
	fake.phrasesForUserWithUUIDMutex.Lock()
	ret, specificReturn := fake.phrasesForUserWithUUIDReturnsOnCall[len(fake.phrasesForUserWithUUIDArgsForCall)]
	fake.phrasesForUserWithUUIDArgsForCall = append(fake.phrasesForUserWithUUIDArgsForCall, struct {
		arg1 uuid.UUID
	}{arg1})
	fake.recordInvocation("PhrasesForUserWithUUID", []interface{}{arg1})
	fake.phrasesForUserWithUUIDMutex.Unlock()
	if fake.PhrasesForUserWithUUIDStub != nil {
		return fake.PhrasesForUserWithUUIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.phrasesForUserWithUUIDReturns.result1, fake.phrasesForUserWithUUIDReturns.result2
}

func (fake *FakePhrasesRepository) PhrasesForUserWithUUIDCallCount() int {
	fake.phrasesForUserWithUUIDMutex.RLock()
	defer fake.phrasesForUserWithUUIDMutex.RUnlock()
	return len(fake.phrasesForUserWithUUIDArgsForCall)
}

func (fake *FakePhrasesRepository) PhrasesForUserWithUUIDArgsForCall(i int) uuid.UUID {
	fake.phrasesForUserWithUUIDMutex.RLock()
	defer fake.phrasesForUserWithUUIDMutex.RUnlock()
	return fake.phrasesForUserWithUUIDArgsForCall[i].arg1
}

func (fake *FakePhrasesRepository) PhrasesForUserWithUUIDReturns(result1 []api.Phrase, result2 error) {
	fake.PhrasesForUserWithUUIDStub = nil
	fake.phrasesForUserWithUUIDReturns = struct {
		result1 []api.Phrase
		result2 error
	}{result1, result2}
}

func (fake *FakePhrasesRepository) PhrasesForUserWithUUIDReturnsOnCall(i int, result1 []api.Phrase, result2 error) {
	fake.PhrasesForUserWithUUIDStub = nil
	if fake.phrasesForUserWithUUIDReturnsOnCall == nil {
		fake.phrasesForUserWithUUIDReturnsOnCall = make(map[int]struct {
			result1 []api.Phrase
			result2 error
		})
	}
	fake.phrasesForUserWithUUIDReturnsOnCall[i] = struct {
		result1 []api.Phrase
		result2 error
	}{result1, result2}
}

func (fake *FakePhrasesRepository) AddPhraseForUserWithUUID(arg1 string, arg2 string, arg3 uuid.UUID) (api.Phrase, error) {
	fake.addPhraseForUserWithUUIDMutex.Lock()
	ret, specificReturn := fake.addPhraseForUserWithUUIDReturnsOnCall[len(fake.addPhraseForUserWithUUIDArgsForCall)]
	fake.addPhraseForUserWithUUIDArgsForCall = append(fake.addPhraseForUserWithUUIDArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 uuid.UUID
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddPhraseForUserWithUUID", []interface{}{arg1, arg2, arg3})
	fake.addPhraseForUserWithUUIDMutex.Unlock()
	if fake.AddPhraseForUserWithUUIDStub != nil {
		return fake.AddPhraseForUserWithUUIDStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.addPhraseForUserWithUUIDReturns.result1, fake.addPhraseForUserWithUUIDReturns.result2
}

func (fake *FakePhrasesRepository) AddPhraseForUserWithUUIDCallCount() int {
	fake.addPhraseForUserWithUUIDMutex.RLock()
	defer fake.addPhraseForUserWithUUIDMutex.RUnlock()
	return len(fake.addPhraseForUserWithUUIDArgsForCall)
}

func (fake *FakePhrasesRepository) AddPhraseForUserWithUUIDArgsForCall(i int) (string, string, uuid.UUID) {
	fake.addPhraseForUserWithUUIDMutex.RLock()
	defer fake.addPhraseForUserWithUUIDMutex.RUnlock()
	return fake.addPhraseForUserWithUUIDArgsForCall[i].arg1, fake.addPhraseForUserWithUUIDArgsForCall[i].arg2, fake.addPhraseForUserWithUUIDArgsForCall[i].arg3
}

func (fake *FakePhrasesRepository) AddPhraseForUserWithUUIDReturns(result1 api.Phrase, result2 error) {
	fake.AddPhraseForUserWithUUIDStub = nil
	fake.addPhraseForUserWithUUIDReturns = struct {
		result1 api.Phrase
		result2 error
	}{result1, result2}
}

func (fake *FakePhrasesRepository) AddPhraseForUserWithUUIDReturnsOnCall(i int, result1 api.Phrase, result2 error) {
	fake.AddPhraseForUserWithUUIDStub = nil
	if fake.addPhraseForUserWithUUIDReturnsOnCall == nil {
		fake.addPhraseForUserWithUUIDReturnsOnCall = make(map[int]struct {
			result1 api.Phrase
			result2 error
		})
	}
	fake.addPhraseForUserWithUUIDReturnsOnCall[i] = struct {
		result1 api.Phrase
		result2 error
	}{result1, result2}
}

func (fake *FakePhrasesRepository) UpdatePhraseForUserWithUUID(arg1 string, arg2 string, arg3 uuid.UUID, arg4 uuid.UUID) (api.Phrase, error) {
	fake.updatePhraseForUserWithUUIDMutex.Lock()
	ret, specificReturn := fake.updatePhraseForUserWithUUIDReturnsOnCall[len(fake.updatePhraseForUserWithUUIDArgsForCall)]
	fake.updatePhraseForUserWithUUIDArgsForCall = append(fake.updatePhraseForUserWithUUIDArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 uuid.UUID
		arg4 uuid.UUID
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UpdatePhraseForUserWithUUID", []interface{}{arg1, arg2, arg3, arg4})
	fake.updatePhraseForUserWithUUIDMutex.Unlock()
	if fake.UpdatePhraseForUserWithUUIDStub != nil {
		return fake.UpdatePhraseForUserWithUUIDStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updatePhraseForUserWithUUIDReturns.result1, fake.updatePhraseForUserWithUUIDReturns.result2
}

func (fake *FakePhrasesRepository) UpdatePhraseForUserWithUUIDCallCount() int {
	fake.updatePhraseForUserWithUUIDMutex.RLock()
	defer fake.updatePhraseForUserWithUUIDMutex.RUnlock()
	return len(fake.updatePhraseForUserWithUUIDArgsForCall)
}

func (fake *FakePhrasesRepository) UpdatePhraseForUserWithUUIDArgsForCall(i int) (string, string, uuid.UUID, uuid.UUID) {
	fake.updatePhraseForUserWithUUIDMutex.RLock()
	defer fake.updatePhraseForUserWithUUIDMutex.RUnlock()
	return fake.updatePhraseForUserWithUUIDArgsForCall[i].arg1, fake.updatePhraseForUserWithUUIDArgsForCall[i].arg2, fake.updatePhraseForUserWithUUIDArgsForCall[i].arg3, fake.updatePhraseForUserWithUUIDArgsForCall[i].arg4
}

func (fake *FakePhrasesRepository) UpdatePhraseForUserWithUUIDReturns(result1 api.Phrase, result2 error) {
	fake.UpdatePhraseForUserWithUUIDStub = nil
	fake.updatePhraseForUserWithUUIDReturns = struct {
		result1 api.Phrase
		result2 error
	}{result1, result2}
}

func (fake *FakePhrasesRepository) UpdatePhraseForUserWithUUIDReturnsOnCall(i int, result1 api.Phrase, result2 error) {
	fake.UpdatePhraseForUserWithUUIDStub = nil
	if fake.updatePhraseForUserWithUUIDReturnsOnCall == nil {
		fake.updatePhraseForUserWithUUIDReturnsOnCall = make(map[int]struct {
			result1 api.Phrase
			result2 error
		})
	}
	fake.updatePhraseForUserWithUUIDReturnsOnCall[i] = struct {
		result1 api.Phrase
		result2 error
	}{result1, result2}
}

func (fake *FakePhrasesRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.phrasesForUserWithUUIDMutex.RLock()
	defer fake.phrasesForUserWithUUIDMutex.RUnlock()
	fake.addPhraseForUserWithUUIDMutex.RLock()
	defer fake.addPhraseForUserWithUUIDMutex.RUnlock()
	fake.updatePhraseForUserWithUUIDMutex.RLock()
	defer fake.updatePhraseForUserWithUUIDMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePhrasesRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.PhrasesRepository = new(FakePhrasesRepository)
